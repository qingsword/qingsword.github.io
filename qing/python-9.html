<!DOCTYPE html>
<!--Copyright©QingSword.COM︻☼1010D>-->
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0,user-scalable=no">
	<meta name="description" content="晴刃,是一个致力推广实用计算机技术的个人博客;我们分享计算机知识;为计算机系统以及网络安全防范做出一份贡献。【专注技术 创造价值 共同进步】">
	<meta name="keywords" content="晴刃,晴,qing,qingsword,ccna图文笔记,ubuntu,linux,ubuntu server,mysql,node.js,javascript,python,计算机技术博客">
	<meta name="author" content="www.qingsword.com">
	<title>[Python]-9-对象与类 - QingSword.COM</title>
	<link rel="shortcut icon" type="image/x-icon" href="../logo/favicon.ico">
	<link rel="stylesheet" type="text/css" href="../css/basic.css">
	<link rel="stylesheet" type="text/css" href="../css/text.css">
	<!-- 代码块高亮js -->
	<link type="text/css" rel="stylesheet" href="../plugins/SyntaxHighlighter/styles/shCore.css"/>
	<link type="text/css" rel="stylesheet" href="../plugins/SyntaxHighlighter/styles/shThemeRDark.css"/>
	<script type="text/javascript" src="../plugins/SyntaxHighlighter/scripts/shCore.js"></script>
	<script type="text/javascript" src="../plugins/SyntaxHighlighter/scripts/shBrushPython.js"></script>
	<script type="text/javascript">
	SyntaxHighlighter.all();
	</script>
</head>
<body>
	<!--header -->
	<header id="nav">
			<div class="nav-container"> 
				<!-- 根大纲-->
				<a href="http://www.qingsword.com" title="晴刃">
					<h1 class="nav-logo">晴刃</h1>
				</a>
				<h2 class="nav-site-description desc-hidden">
					自由、互助、分享、专注计算机技术
				</h2>
				<nav class="nav-links"> 
					<!-- nav连接大纲-->
					<h1 style="display:none;">网站导航</h1> 
					<ul>
						<li  class="li-hidden">
							<a href="../index.html" title="home">
								<span class="link-word"><img src="../logo/home.png" alt="home" class="link-img">首页</span>
							</a>
						</li>
						<li class="li-hidden">
							<a href="../web.html" title="web">
								<span class="link-word"><img src="../logo/web.png" alt="web" class="link-img">前端<span class="word-hidden">设计</span></span>
							</a>
						</li>
						<li class="li-hidden">
							<a href="../system.html" title="system">
								<span class="link-word"><img src="../logo/linux.png" alt="linux" class="link-img">系统<span class="word-hidden">应用</span></span>
							</a>
						</li>
						<li class="li-hidden">
							<a href="../net.html" title="net">
								<span class="link-word"><img src="../logo/net.png" alt="net" class="link-img">网络<span class="word-hidden">技术</span></span>
							</a>
						</li>
						<li>
							<a href="../sitemap.html" title="sitemap">
								<span class="link-word"><img src="../logo/archives.png" alt="archives" class="link-img"><span class="word-hidden">文章</span>归档</span>
							</a>
						</li>
					</ul>
				</nav>
			</div>		
	</header>
	<!-- /header -->

	<!-- content-->
	<div id="content">
		<div class="content-container">
			<!-- 文章区 -->
			<article class="text-container">
				<header class="text-header">
					<h1>[Python]-9-对象与类</h1>	
				</header><!-- /header -->
				<section class="text-body">
					<h2>引言</h2>
					<p>这篇文章介绍Python如何将函数与数据整合成类，并通过一个对象名称来访问它们。</p>
					<!-- 目录 -->
					<h2>文章目录</h2>
					<ul class="contents">	
						 <li><a href="#python-class-1">0×1.什么是python中的对象</a></li>
						 <li><a href="#python-class-2">0×2.python中如何创建类</a></li>
						 <li><a href="#python-class-3">0×3.类私有属性访问限制</a></li>
						 <li><a href="#python-class-4">0×4.继承与多态</a></li>
						 <li><a href="#python-class-5">0×5.获取对象信息</a></li>
						 <li><a href="#python-class-6">0×6.实例属性与类属性</a></li>
					 </ul>
					<!-- /目录 -->

					<!-- 正文 -->
					<h2 id="python-class-1">0×1.什么是python中的对象</h2>

					<p>Python中每条数据都是对象，每个对象都由三部分组成：标识，数据，类型；</p>

					<p>标识是对象的名称，也储存了该对象的内存地址（对象引用），类型规定了这个对象所能储存的值的类型，内存中的某块区域保存了对象的数据值；</p>

					<p>在之前的文章中，我们定义的字符串，列表，字典等，都是对象，每个对象都有其内置的一些方法，例如对字符串对象使用len()方法可以求出字符串的长度，我们可以在IDLE中使用dir()方法来查看某个对象可以使用的方法，如下：</p>
					<pre class="brush: python;">
					&gt;&gt;&gt; s="www.qingsword.com"
					&gt;&gt;&gt; dir(s)
					['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

					#上面中括号中的所有输出，以逗号分隔，每一个都是字符串对象可以使用的方法，其中带双下划线的为"内部方法"，不带下划线的为"外部方法"也叫"接口函数"，"内部方法"通常对用户是不可见的，但这并不意味着内部方法就是不可调用的，实际上我们对某个字符串对象使用len()函数的时候，就是调用了其内部的__len__方法，通过下面的实例可以看到，两者的输出是相同的
					&gt;&gt;&gt; print(len(s))
					17
					&gt;&gt;&gt; print(s.__len__())
					17
					</pre>
					<p>实际上，我们定义一个字符串对象的时候，python在其内部初始化了一个str类，这个类中包含了python提供的对字符串处理的内置方法，现在这么说可能有点生疏，等大家看完第二段自己手动创建了一个类之后，就会明白上面这些内部方法和接口函数的工作原理了。</p>

					<h2 id="python-class-2">0×2.python中如何创建类</h2>

					<p>python中的类，实际上是完成某个工作的对象和函数的集合，当一个类被调用时，它创建了绑定到一个名称的对象，请看下面的实例，这是一个经典的电冰箱实例，我们假设要创建一个类，用于将食物放入冰箱，查询冰箱中有哪些食物，然后提供取出食物的一系列方法：</p>
					<pre class="brush: python;">
					#!/usr/bin/env python3
					#coding=utf-8

					########
					class Fridge:
					    """电冰箱类实例"""

					    #--------
					    def __init__(self,items={}):
					        """类初始化"""
					        if type(items)!=type({}):
					            raise TypeError("传入参数错误:%s"%items)
					        self.items=items
					########

					#python使用class关键字来定义一个类，本例定义了一个Fridge类，在这个类中有一个内部方法__init__，每个类都可以包含这个方法，也可以不包含，这个方法的作用是，当使用名称初始化一个Fridge对象时，自动执行__init__函数中的代码，相当于类的初始化操作

					#注意def __init__(self,items={})部分中的self参数，这是python独有的语法，self总是代表类对象本身，这段初始化代码初始化了一个空字典对象，如果不好理解self，可以尝试着将代码中的self省去，然后观察这段函数，实际上__init__就接收一个参数，这个参数必须是一个字典对象，如果省去这个参数，那么默认初始化一个空自字典，并且在Fridge内部使用items对象保存这个字典的数据，但实际情况下self参数不能省略

					#现在我们已经有了一个Fridge类，可以通过下面的方法创建这个类的对象实例，下面的语法没有给Fridge传递参数，所以将初始化一个空的字典，如果想要传递参数，可以这么写p=Fridge({"apple":1,"orange":3})，如果这样，那么Fridge中的items对象就将保存{"apple":1,"orange":3}这个字典
					p=Fridge()

					#现在有一个新的对象p，他是一个完整的Fridge类对象，在上面的创建过程中，Fridge类执行了__init__方法，这将创建一个空的字典对象，可以通过"类实例名称.类对象名称"来访问到这些数据
					print(p.items)

					#输出
					{}
					</pre>

					<p>现在，可以给Fridge类添加一系列方法来提供必要的功能了，在Fridge类中补充下面的内容，用于添加查询或删除食物：</p>
					<pre class="brush: python;">
					#!/usr/bin/env python3
					#coding=utf-8

					########
					class Fridge:
					    """电冰箱类实例"""

					    #--------
					    def __init__(self,items={}):
					        """类初始化"""
					        if type(items)!=type({}):
					            raise TypeError("传入参数错误:%s"%items)
					        self.items=items
					    
					    #--------
					    def __add_multi(self,food_name,quantity):
					        """内部方法，向items字典添加键值，如果food_name不在items字典的键列表中，说明这是一个新添加的食物，将数量初始化为0，然后加上传递给这个函数的quantity的值（可能是一个或者多个）"""
					        if (not food_name in self.items.keys()):
					            self. items[food_name]=0
					        self.items[food_name]=self.items[food_name]+quantity
					    
					    #--------
					    def add_one(self,food_name):
					        """向items字典添加单个食物，这就是一个接口函数，通过调用内部方法__add_multi完成添加食物到冰箱的工作"""
					        if type(food_name)!=type(""):
					            raise TypeError("食物名称类型错误：%s，正确的数据类型：%s"\
					                            %(type(food_name),type("")))
					        else:
					            self.__add_multi(food_name,1)
					        return True
					    
					    #--------
					    def add_many(self,food_dict):
					        """像items字典添加多个食物，这个接口函数接收一个字典参数food_dict，使用for循环遍历这个传递过来的字典中的键名，然后将名称和数量传递给__add_multi函数"""
					        if type(food_dict)!=type({}):
					            raise TypeError("食物名称和数量必须使用字典，错误的数据输入：%s"%food_dict)
					        else:
					            for food_name in food_dict.keys():
					                self.__add_multi(food_name,food_dict[food_name])
					                
					    #--------
					    def has(self,food_name,quantity=1):
					        """查看items中是是否还有某个食物，如果只向这个接口函数传递一个食物名称，那么quantity默认为1，他将调用下面的has_various函数，将食物名称和食物数量传递过去，用于判断冰箱中还有没有这么多的食物"""
					        return self.has_various({food_name:quantity})
					    
					    #--------
					    def has_various(self,foods):
					        """查看食物是否低于输入值，这个接口函数接受一个字典类型的传入参数，通过遍历这个传入的字典中的键名，判断Fridge的items字典中对应键的值是否小于传递进来的这个列表中的每个食物的值，如果小于就返回False，代表冰箱中没有那么多食物了，如果传入的食物名称不存在，会产生一个KeyError异常，同样返回False"""
					        try:
					            for food in foods.keys():
					                if self.items[food]&lt;foods[food]:
					                    return False
					                return True
					        except KeyError:
					            return False
					            
					    #--------
					    def __get_multi(self,food_name,quantity):
					        """取出食物的内部方法，这个方法接受两个值，一个为食物名称，一个为食物数量，第一个if判断冰箱中是否存在这个食物，第二个if调用has()函数将食物名称和数量传递给它，用于判断冰箱中是否还有这么多食物，如果有，则从中取出对应数量的食物，第三个if在刚才取出食物后，判断该食物是否还有库存，如果食物数量为0，则从字典中删除这个食物"""
					        if not food_name in self.items.keys():
					            print("冰箱中并没有这个食物:%s，取出失败"%food_name)
					            return False
					        if self.has(food_name,quantity):
					            self.items[food_name]-=quantity     
					            print("成功取出:%s，数量%s"%(food_name,quantity))
					        if self.items[food_name] == 0:
					            self.items.pop(food_name)
					        return True
					     
					    #--------
					    def get_one(self,food_name):
					        """取出某个食物，调用内部方法__get_multi取出单个食物"""
					        if type(food_name)!=type(""):
					            raise TypeError("食物名称类型错误：%s，正确的数据类型：%s"\
					                                        %(type(food_name),type("")))
					        else:
					            self.__get_multi(food_name, 1)
					        return True
					     
					    #--------
					    def get_many(self,food_dect):
					        """取出多个食物，这个函数接收一个字典参数，for循环遍历这个传入的字典中的键列表，然后判断Fridge类中items字典中这个名称对应的数量是否大于等于传入的这个字典中设置的数量，如果判断成立，表示冰箱中还有足够的食物，调用__get_multi取出这些食物和对应的数量，如果不满足条件，则提示用户，库存补足和现有数量"""
					        if type(food_dect)!=type({}):
					            raise TypeError("食物名称和数量必须使用字典，错误的数据输入：%s"%food_dict)
					        for food in food_dect.keys():
					            if self.items[food]&gt;=food_dect[food]:
					                self.__get_multi(food,food_dect[food])
					            else:
					                print("食材：%s，库存不足，现有数量：%s"%(food,self.items[food])) 
					########       
					
					#初始化Fridge类
					p=Fridge()
					print(p.items)

					#分别调用add函数，像Fridge类添加单个和多个食物
					d={"orange":5,"apple":3}
					p.add_one("banana")
					p.add_many(d)
					print(p.items)

					#如果Fridge中至少有一个orange，取出它
					if p.has("orange"):
					    p.get_one("orange")
					    print(p.items)
					else:
					    print("冰箱里已经没有orange了")
					 
					#如果冰箱中还有5个apple告知用户，如果没有输出现有apple数量
					if p.has("apple",5):
					    print("冰箱里至少还有5个apple")
					else:    
					    print("冰箱里的apple数量:%s"%p.items["apple"])
					
					#判断冰箱中是否有字典中这些食物和数量，如果有取出它们
					if p.has_various({"apple":2,"orange":2,"banana":1}):
					    p.get_many({"apple":2,"orange":2,"banana":1})
					print(p.items)

					#因为冰箱中只有1个banana，刚才已经取出了，所以这里会提示并没有这个食物
					p.get_one("banana")

					#提示库存补足，因为现在只有一个apple在冰箱中
					p.get_many({"apple":3})
					    
					#程序输出
					{}
					{'banana': 1, 'apple': 3, 'orange': 5}
					成功取出:orange，数量1
					{'banana': 1, 'apple': 3, 'orange': 4}
					冰箱里的apple数量:3
					成功取出:banana，数量1
					成功取出:apple，数量2
					成功取出:orange，数量2
					{'apple': 1, 'orange': 2}
					冰箱中并没有这个食物:banana，取出失败
					食材：apple，库存不足，现有数量：1
					</pre>

					<h2 id="python-class-3">0×3.类私有属性访问限制</h2>

					<p>在上面的电冰箱实例中，我们已经创建过了私有方法，python中所谓的私有方法和属性，就是在这些方法或属性名前添加两个"下划线"（例如__items），这样的属性或方法是不能用正常的方法访问到的，但不包括前后双下划线的那些（例如__len__），下面用一个实例来演示这些私有属性和方法的特性：</p>
					<pre class="brush: python;">
					#!/usr/bin/env python
					#coding=utf-8
					########
					class Kitty(object):
					    """私有属性__name和__age的类"""
					    #--------
					    def __init__(self,name="hello",age=1):
					        """初始化"""
					        self.__name=name
					        self.__age=age
					    #私有属性可以通过接口函数来调用
					    #--------
					    def get_age(self):
					        """返回年龄"""
					        return self.__age
					    #--------
					    def set_age(self,age):
					        """设置年龄"""
					        self.__age=age
					    #--------
					    def get_name(self):
					        """返回名字"""
					        return self.__name
					    #--------
					    def set_name(self,name):
					        """设置名字"""
					        self.__name=name
					    #前后双下划线的方法，不是私有方法，外部可以直接访问，只有前置双下划线的属性或方法才是私有的，自能通过内部接口函数调用
					    #--------
					    def __get_name_len__(self):
					        return len(self.__name)
					
					#实例化      
					kt=Kitty()
					#通过接口函数设置年龄和姓名
					kt.set_age(2)
					kt.set_name("www.qingsword.com")
					#通过接口函数打印姓名和年龄
					print(kt.get_name())
					print(kt.get_age())
					#打印出名字长度
					print(kt.__get_name_len__())

					#程序输出
					www.qingsword.com
					2
					17

					#从这个实例可以看出，前后带双下划线的方法或属性，都能直接访问到，而如果我们输入下面这3句，发现并没有报错，不是说私有属性不能直接访问吗，为什么可以直接kt.__name设置私有属性的值呢？这是因为，实际上我们使用实例kt.__name这种语法的时候，是对kt这个类实例，创建了一个新的属性__name，这个属性和Kitty内部的私有属性并不是一个属性，内部的__name属性已经被python解释器自动改名为_Kitty__name了
					kt.__name="qingsword.com"
					print(kt.__name)
					print(kt._Kitty__name)

					#从下面的程序输出可以看到，两者保存的数据并不相同
					qingsword.com
					www.qingsword.com

					#这并不意味着外部就真的无法调用这些私有属性或方法，只是python解释器自动对这些私有数据添加了类名前缀，可以给私有属性添加带但下划线的类名前缀来直接访问他们，但并不推荐这么做
					kt._Kitty__name="www.qingsword.com"

					#可能大家会觉得很奇怪，为什么要添加这些私有的属性或方法，直接提供访问不好吗？实际上，可以通过创建接口函数，对私有数据进行过滤处理，例如
					    #--------
					    def set_age(self,age):
					        """设置年龄"""
					        if 0&lt;=age&lt;=150:
					            self.__age=age
					        else:
					            print("年龄不科学")
					</pre>

					<h2 id="python-class-4">0×4.继承与多态</h2>

					<p>我们在创建类的时候，默认情况下都是继承了python的基类object，除此之外，我们还能让新建的类继承现有的类，继承后子类将拥有被继承的父类所有的属性和方法，下面用一个实例来演示这一特性：</p>
					<pre class="brush: python;">
					#!/usr/bin/env python
					#coding=utf-8
					########
					class Parent(object):
					    """父类，继承了object类，如果一个类是继承基类object，可以省略(object)不写，但写上也不会报错"""
					    #--------
					    def print_website(self):
					        """打印网址"""
					        print("www.qingsword.com")
					    #--------
					    def print_author(self):
					        """打印作者名称"""
					        print("QingSword")
					########
					class Sub_A(Parent):
					    """继承Parent的子类，将父类写在子类后面的括号中，表示继承其所有的方法和属性，Sub_A重写了父类的print_website方法"""
					    #--------
					    def print_website(self):
					        """打印网址"""
					        print("qingsword.com")
					########
					class Sub_B(Parent):
					    """继承Parent的子类，仅仅是一个空类，但却可以使用父类所有属性或方法"""
					########
					class Sub_C(object):
					    """继承object的子类"""
					    #--------
					    def print_author(self):
					        print("qingsword")
					        
					#--------
					def print_info(x):
					    """打印作者信息"""
					    x.print_author()
					
					#首先实例化四个类
					p=Parent()
					a=Sub_A()
					b=Sub_B()
					c=Sub_C()

					#访问父类的两个方法
					p.print_website()
					p.print_author()
					#程序输出
					www.qingsword.com
					QingSword

					#访问子类A的两个方法，如果一个子类中有与父类同名的属性或方法，那么它将覆盖父类的属性或方法，A类中重写了父类的print_website()，所以会优先被调用，虽然A类并没有print_author()方法，但是它将从父类Parent中继承这个方法，除非重写这个方法，否则就将直接调用父类的方法打印出作者信息
					a.print_website()
					a.print_author()
					#程序输出
					qingsword.com
					QingSword

					#B类中什么都没写，但他继承了父类Parent
					b.print_author()
					b.print_website()
					#程序输出
					www.qingsword.com
					QingSword
					
					#再来看看这些对象他们的类型都是什么

					#Parent类是继承object的，所以它可以是object类型，也可以是Parent类型，但不能是其子类型
					print(isinstance(p,Parent))
					print(isinstance(p,object))
					print(isinstance(p,Sub_A))
					#程序输出
					True
					True
					False

					#所有的子类型，可以是其父类型或Python基类object，也可以是其自身，所以下面的输出都是True
					print(isinstance(a,Parent))
					print(isinstance(a,Sub_A))
					print(isinstance(b,Parent))
					print(isinstance(b,Sub_B))

					#像print_info()方法传递四个类，四个类可以是不同类型，甚至可以像print_info()传递其他方法名称，这是高级动态语言的一个最强大的地方——多态：print_info()方法接收一个变量，它不管接收的变量是什么类型，只关心这个变量能不能访问print_author()方法，这就是为什么C类虽然是继承了object，但它也有print_author()方法，所以程序不会报错
					print_info(p)
					print_info(a)
					print_info(b)
					print_info(c)
					#程序输出
					QingSword
					QingSword
					QingSword
					qingsword
					</pre>
					<h2 id="python-class-5">0×5.获取对象信息</h2>

					<p>除了使用isinstance来匹配对象类型外，还能使用type来获取这些对象的类型，请看下面的实例：</p>
					<pre class="brush: python;">
					#!/usr/bin/env python
					#coding=utf-8
					#types模块中定义的常量可用于判断函数类型
					import types
					
					#输出对象的类型
					print(type("www.qingsword.com"))
					#判断对象是否为字符串类型
					print(type("qingsword.com")==str)
					#程序输出
					&lt;class 'str'&gt;
					True

					#如果对象是一个函数，就需要借助types模块中定义的常量来判断了
					#--------
					def fx():
					    return 0

					#判断fx是否为函数类型
					print(type(fx)==types.FunctionType)

					#判断是否为lambda类型
					print(type(lambda :0)==types.LambdaType)

					#判断len是否为内置的函数类型
					print(type(len)==types.BuiltinFunctionType)

					#判断表达式是否为列表生成器类型
					print(type((x for x in range(10)))==types.GeneratorType)

					#程序输出都为True

					#isinstance同样能够完成这些操作，例如将判断fx函数的语句改成下面这样，返回值同样是True
					print(isinstance(fx,types.FunctionType))
					</pre>
					<p>除了上面的两种对象类型判断外，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态，请看下面的实例：</p>
					<pre class="brush: python;">
					#!/usr/bin/env python
					#coding=utf-8
					class Ob_A(object):
					    #---------
					    def __init__(self,x=0):
					        if type(x)==int:
					            self.a=x
					        else:
					            raise TypeError("传入参数类型(%s)错误,正确的参数类型int"%type(x))
					    #---------
					    def sq(self):
					        return self.a*self.a

					oba=Ob_A(12)

					#判断oba对象中是否有属性(或方法)a，返回True
					print(hasattr(oba,"a"))

					#获取属性(或方法)a，本例中a是一个属性值12，所以被print直接打印了出来
					print(getattr(oba,"a"))

					#是否有属性(或方法)b，返回False
					print(hasattr(oba,"b"))

					#给对象设置一个属性b，值为13
					setattr(oba,"b",13)

					#因为已经给对象添加了属性b，再次判断，返回True，并且打印出b的值13
					print(hasattr(oba,"b"))
					print(getattr(oba,"b"))

					#判断oba对象中是否存在sq属性(或方法)
					print(hasattr(oba,"sq"))

					#使用sq对象指向oba对象的sq方法
					sq=getattr(oba,"sq")

					#从type可以看到sq是一个方法类型
					print(type(sq))

					#执行sq方法，返回144
					print(sq())

					#程序输出
					True
					12
					False
					True
					13
					True
					&lt;class 'method'&gt;
					144
					</pre>
					<p>这三个函数可用于探测对象中的信息，只有在不知道对象信息的时候，才会使用这三个函数，如果已经明确知道了一个对象中包含了哪些属性和方法，请直接调用他们。</p>

					<h2 id="python-class-6">0×6.实例属性与类属性</h2>

					<p>python是动态语言，在实例化后，还能给实例添加新的属性，但最好不要与类中的属性同名，请看下面的实例：</p>

					<pre class="brush: python;">
					#!/usr/bin/env python
					#coding=utf-8
					#Ob_A类中定义了一个类属性x，并且配置了其值为2
					class Ob_A(object):
					    x=2
					
					#实例化Ob_A类
					oba=Ob_A()

					#给oba实例创建一个新属性x，因为和Ob_A类中的属性同名，所以会覆盖原有属性值
					oba.x=1

					#打印出1
					print(oba.x)

					#类中的属性保持不变，打印出2
					print(Ob_A.x)

					#此时如果手动删除oba实例的x对象，再次打印oba实例的x对象，就会打印出原类中绑定的属性x值，打印出2
					del oba.x
					print(oba.x)

					#程序输出
					1
					2
					2
					</pre>
					<p>类在实例化后，如果需要给实例新增属性，建议属性名不要使用与原类中已经存在的属性同名，因为相同名称的实例属性将屏蔽掉类属性。</p>
						
				<!-- /正文 -->

				<footer class="text-footer">
					<p>
						*转载请注明来自:<a title="晴刃-自由、互助、分享、专注计算机技术。" href="http://www.qingsword.com" target="_blank">晴刃(QingSword.COM)</a>
					</p>
					<p>*原文连接:<a title="[Python]-9-对象与类" href="http://www.qingsword.com/qing/python-9.html" target="_blank">http://www.qingsword.com/qing/python-9.html</a></p>
				</footer>
			</article>
			<!-- /文章区 -->	
		</div>
	</div>
	<!-- /content -->
	
	<!-- footer -->
	<footer id="footer">
		<div class="footer-container">
			QingSword.COM &nbsp;<img src="../logo/by-nc-sa.png" alt="Creative Commons" title="Creative Commons">
		</div>
	</footer>
	<!-- /footer -->
</body>
</html>